# DelaTorre_OBT4

A React Native application demonstrating state management and API integration.
## Screenshots
<table>
  <tr>
    <td align="center"><b>Loading State</b></td>
    <td align="center"><b>Error State</b></td>
    <td align="center"><b>Empty State</b></td>
    <td align="center"><b>Successful Render</b></td>
  </tr>
  <tr>
    <td><img src="https://github.com/user-attachments/assets/eed7e068-c4c0-4835-80e6-f1f2b45b43bb" width="100%" alt="Loading"></td>
    <td><img src="https://github.com/user-attachments/assets/811ba675-3ffb-4300-b081-c2971ea73e2a" width="100%" alt="Error"></td>
    <td><img src="https://github.com/user-attachments/assets/91fc6eda-ecb1-4bba-ae1d-68f5f3a6a7f4" width="100%" alt="Empty"></td>
    <td><img src="https://github.com/user-attachments/assets/591f3931-2376-4f64-8521-2613fe8b1455" width="100%" alt="Success"></td>
  </tr>
</table>


## Architecture

The project uses a simple component hierarchy where `App.tsx` wraps navigation and context providers. Screens and components live under `src/screens` and `src/components` while service logic lives in `src/services`. Native iOS/Android folders contain the platform-specific build files generated by React Native CLI. The architecture favors separation of concerns: UI components are dumb, business logic lives in services, and global state is handled centrally.

Application-wide state is managed using React's Context API along with a reducer pattern. A `ProductContext` provides state and dispatch to any component tree that needs product data or actions. This avoids prop drilling by allowing deeply nested screens to access and update state through context hooks.

## Global State with Context API

The Context API creates a provider component that wraps the app and supplies state values and dispatch functions. Components call `useContext(ProductContext)` to read from or update the global store. The internal reducer handles actions (like `SET_PRODUCTS`) to ensure predictable state transitions and keep components in sync.

## API Integration

The application uses a custom Axios instance defined in `src/services/api.js`. Creating an Axios instance lets us centralize base URL configuration, headers, and interceptors for authentication or logging. This way, every service function imports the same instance, ensuring consistent networking behavior and easing future changes.


